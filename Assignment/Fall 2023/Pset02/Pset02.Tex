\documentclass[12pt]{article}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\input{etc/cmd}


\begin{document}
\fontsize{12pt}{14pt}\selectfont
\input{etc/head}


\section{سوال اول 3.0}
در این سوال، شما یک $Doubly Linked list$ را پیاده سازی خواهید کرد که از برخی عملیات زمان ثابت اضافی پشتیبانی می کند. هر گره $x$ از یک $Doubly Linked list$، یک اشاره گر $x.prev$ به گره قبل از آن در دنباله، علاوه بر یک اشاره گر $x.next$ به گره بعد از آن در دنباله نگه می دارد. یک $Doubly Linked list$ $L$ یک اشاره گر به $L.tail$، آخرین گره در دنباله، علاوه بر $L.head$، اولین گره در دنباله را نگه می دارد.
\\

برای این سوال، لیست های دارای پیوند دوگانه نباید طول خود را پیگیری کند($track$ $keeping$)

\begin{enumerate}[label=\alph*)]
    \item یک $Doubly Linked list$ دارید، الگوریتم هایی را برای اجرای عملیات های زیر، هر کدام در زمان $O(1)$ توصیف کنید.
        \begin{itemize}
            \item  $first(x)$ $insert$ 
            \item  $last(x)$ $insert$
            \item  $first()$ $delete$
            \item  $last()$ $delete$
        \end{itemize}
    \item دو گره $x1$ و $x1$ در یک $Doubly Linked list$ با نام $L$ فرض کنید، که در آن $x1$ قبل از  $x2$ قرار گرفته، یک الگوریتم زمان ثابت را برای حذف تمام گره‌ها از $x1$ تا $x2$ از $L$ توصیف کنید و آنها را به عنوان یک $Doubly Linked list$ جدید برگردانید.
\end{enumerate}


\section{سوال دوم 4.0}
برای هر یک از سناریوهای زیر، یک الگوریتم مرتب‌سازی (از هر کدام از $selection sort$، $insertion sort$ یا $merge sort$) که بهترین کاربرد را دارد، انتخاب کنید و انتخاب خود را توجیه کنید. این را فراموش نکنید! ارزش دلیل شما بیشتر از انتخاب شما خواهد بود. 
\\
\\
هر الگوریتم $sort$ ممکن است بیش از یک بار استفاده شود. اگر متوجه شدید که چندین نوع می‌توانند برای یک سناریو مناسب باشند، مزایا و معایب آن‌ها را شناسایی کنید و یکی را انتخاب کنید که برای برنامه کاربردی مناسب‌تر است. هر فرضی که می کنید را بیان و توجیه کنید. معای "بهترین" باید با زمان $asymptotic$ اجرا ارزیابی شود.

\begin{enumerate}[label=\alph*)]
    \item فرض کنید به شما یک ساختار داده $D$ داده شده است با $n$ آیتم و از دو عملیات استاندارد پشتیبانی می کند: $D.get_at(i)$ که در بدترین حالت $\theta(1)$  اجرا میشود و $D.set_at(i, x)$ در بدترین حالت $\Theta(n log n)$  اجرا میشود. الگوریتمی را انتخاب کنید تا موارد را در $D$ به بهترین نحو در محل مرتب کند.
    \\
    به در محل بودن این مرتب سازی توجه کنید.
    \item فرض کنید یک $array$ $static$ با نام $A$ دارید حاوی نشانگرهایی به $n$ شی قابل مقایسه دارید، جفت‌هایی که مقایسه شان زمان $\theta(log n)$ برای مقایسه نیاز دارند. الگوریتمی را انتخاب کنید تا نشانگرها را در $A$ به بهترین نحو مرتب کند تا اشیاء اشاره شده به ترتیب غیر کاهشی ظاهر شوند.
    \item فرض کنید یک آرایه مرتب شده $A$ دارید که حاوی $n$ عدد صحیح است که هر کدام در یک $word$ $Machine$ قرار می گیرند. حال فرض کنید شخصی $log log n$ عملیات $Swap$ بین جفت آیتم های مجاور در $A$ انجام می دهد به طوری که $A$ دیگر مرتب نمی شود. الگوریتمی را انتخاب کنید تا اعداد صحیح در $A$ را به بهترین نحو مرتب کند.
\end{enumerate}


\section{سوال سوم 4.0}
در یک آرایه، یک نابه جایی برابر یک جفت جایگاه است که عدد داخل جایگاه اولی بزرگتر از عدد داخل جایگاه دومی باشد. برای مثال در یک آرایه مرتب شده تعداد نابه جایی ها برابر صفر است و در یک آرایه مرتب شده برعکس این تعداد برابر $\binom{n}{2}$ است.


\begin{enumerate}[label=\alph*)]
    \item  ثابت کنید اگر تعداد نابه جایی های یک آرایه $d$ باشد و الگوریتم $sort$ $insertion$ را روی آن اجرا کنیم با مرتبه زمانی $O(n+d)$ مرتب سازی انجام می شود.
    \item فرض کنید یک آرایه نامرتب به ما داده اند به طوری که هر کس با جایگاه اصلی آن حداکثر ۱۰ جایگاه فاصله دارد.
    برای مثال عدد کمینه حداکثر در اندیس ۱۰ است. (آرایه از اندیس صفر شروع می شود.) با ارائه روش مناسب برای مرتب سازی ثابت کنید این کار در مرتبه زمانی $O(n)$ ممکن است.
\end{enumerate}



\section{سوال چهارم 2.0}
قطعه کدهای $Enqueue$ و $Dequeue$ را جهت $overflow$ و $underflow$ پیاده سازی کنید.

\section{سوال پنجم 2.0}
آیا میتوان عملگر داینامیک $Insert$ را روی یک لیست پیوندی یک طرفه در زمان $O(1)$ پیاده سازی کرد؟ در مورد عملگر $Delete$ چطور؟



\end{document}